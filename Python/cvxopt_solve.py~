class Cvxopt_Solve:
    def __init__(self, marg_xy, marg_xz, _set_to_zero=set()):
        # marg_xy is a dictionary     (x,y) --> positive double
        # marg_xz is a dictionary     (x,z) --> positive double

        self.orig_marg_xy = None
        self.orig_marg_xz = None
        self.var_eps      = None
        self.q_xy         = None
        self.q_xz         = None
        self.var_idx      = None
        self.X            = None
        self.Y            = None
        self.Z            = None
        self.A            = None
        self.b            = None
        self.marg_of_idx  = None  # triples xyz -- the missing one is None
        self.create_equations_called = False
        self.G            = None
        self.h            = None
        self.create_ieqs_called = False
        self.p_0          = None # initial solution
        self.solver_ret   = None
        self.p_final      = None
        self.set_to_zero  = _set_to_zero

        # Options:
        self.expensive_initial_solution = False
        self.verbose_output             = False

        # Actual code:
        self.orig_marg_xy = dict(marg_xy)
        self.orig_marg_xz = dict(marg_xz)
        self.X = set( [ x   for x,y in self.orig_marg_xy.keys() ] + [ x   for x,z in self.orig_marg_xz.keys() ] )
        self.Y = set( [  y  for x,y in self.orig_marg_xy.keys() ] )
        self.Z = set(                                               [  z  for x,z in self.orig_marg_xz.keys() ] )
    # __init__()

    # tidy_up_distrib():
    def tidy_up_distrib(self,p, eps):
        # returns a tidied-up copy of p: every entry smaller than eps is treated as 0.
        p_new = dict()
        one = 0.
        for x,r in p.items():
            if r>=eps:
                p_new[x] = r
                one += r
        # Re-normalize --- Should I drop this ??? ?!?
        for x,r in p_new.items():
            p_new[x] = r / one;

        return p_new
    #^ tidy_up_distrib()

    # create_equations():
    def create_equations(self):
        # The point is that all the double values are considered non-zero
        # This function
        #  - creates the sets X,Y,Z
        #  - creates the dictionary var_idx: variables --> index of the variable
        #  - creates the matrices A,b: two types of marginal equations: p(x,y,*)==p_xy(x,y), p(x,*,z)==p_xz(x,z)
        #  - A has full rank: unneeded eqns are thrown out
        if self.create_equations_called:
            print("Some dork called create_equations twice...")
            exit(1)
        self.create_equations_called = True

        count_vars = 0
        self.var_idx    = dict()
        for x in self.X:
            for y in self.Y:
                if (x,y) in self.q_xy.keys():
                    for z in self.Z:
                        if (x,y,z) not in self.set_to_zero  and  (x,z) in self.q_xz.keys():
                            self.var_idx[ (x,y,z) ] = count_vars
                            count_vars += 1

        list_b           = [] # list of RHSs
        list_At          = [] # coefficient matrix in row-major (need column-major later)
        list_At_throwout = [] # DEBUG: omited equations go here---then we check whether the ranks are equal
        numo_thrownout   = 0

        self.marg_of_idx = []
        # xy-marginal equations
        for xy,rhs in self.q_xy.items():
            x,y = xy
            a = [ 0   for xyz in self.var_idx.keys() ] # initialize the whole row with 0
            for z in self.Z:
                if (x,y,z) in self.var_idx.keys():
                    i  = self.var_idx[ (x,y,z) ]
                    a[i] = 1.
            # list_At += a # splice !
            # list_b.append( rhs )
            # self.marg_of_idx.append(  (x,y,None)  )

            # We test if adding this equation increases the rank.
            # Because of the deleted variables (in set_to_zero), I don't know of a better way to do this...
            tmp_At = matrix( list_At+a, ( len(self.var_idx),  len(list_b)+1 ), 'd' )
            if numpy.linalg.matrix_rank( tmp_At ) > len(list_b):
                list_At += a # splice !
                list_b.append( rhs )
                self.marg_of_idx.append(  (x,None,z)  )

        # xz-marginal equations
        for xz,rhs in self.q_xz.items():
            x,z = xz
            a = [ 0   for xyz in self.var_idx.keys() ] # initialize the whole row with 0
            for y in self.Y:
                if (x,y,z) in self.var_idx.keys():
                    i = self.var_idx[ (x,y,z) ]
                    a[i] = 1.
            # Rank-check again:
            tmp_At = matrix( list_At+a, ( len(self.var_idx),  len(list_b)+1 ), 'd' )
            if numpy.linalg.matrix_rank( tmp_At ) > len(list_b):
                list_At += a # splice !
                list_b.append( rhs )
                self.marg_of_idx.append(  (x,None,z)  )

        # Now we create the CvxOpt matrix.
        self.b  = matrix( list_b,                   ( len(list_b),        1                          ), 'd' )
        At      = matrix( list_At,                  ( len(self.var_idx),  len(list_b)                ), 'd' )
        self.A = At.T
        rk = numpy.linalg.matrix_rank(self.A)
        if ( rk != len(list_b) ):
            print("BUG: There's something wrong with the rank of the coefficient matrix: it is ",rk," it should be ",len(list_b))
            exit(1)
        dim_space = len(self.var_idx)-rk
        print("Solution space has dimension ",dim_space)
    #^ create_equations()

    # create_ieqs():
    def create_ieqs(self):
        if not self.create_equations_called:
            print("You have to call create_equations() before calling create_ieqs()")
            exit(1)
        if self.create_ieqs_called:
            print("Some dork called create_ieqs() twice...")
            exit(1)
        self.create_ieqs_called = True
        self.G = spdiag( matrix( -1., (len(self.var_idx),1), 'd' ) )
        self.h = matrix( 0, (len(self.var_idx),1), 'd' )
    #^ create_ieqs()

    # CALLBACK fn for computing  f, grad f, Hess f
    def callback(self,p=None, zz=None):
        N = len(self.var_idx)
        if p is None:
            list_p_0 = [ 0.   for xyz in self.var_idx.keys() ]
            for xyz,i in self.var_idx.items():
                list_p_0[i] = 1. # self.p_0[xyz]
            # This is returns the starting solution for the iterative solution of the CP --- this is the 1st point to experiment with other distributions with the same marginals.
            return 0, matrix(list_p_0, (N,1), 'd' )

        # check if p is in the feasible region for the objective function:
        if min(p) <= 0 or max(p) > 1:
            return None

        p_dict = dict( (xyz,p[i]) for xyz,i in self.var_idx.items() )
        p_yz = marginal_yz(p_dict)

        # Compute f(p)
        f = 0
        for xyz,i in self.var_idx.items():
            x,y,z = xyz
            if p[i] > 0: f += p[i]*log(p[i]/p_yz[y,z])
#            if p[i] > 1.e-10: f += p[i]*log(p[i]/p_yz[y,z])

        # Compute gradient-transpose Df(p)
        list_Df = [ 0. for xyz in self.var_idx.keys() ]
        for xyz,i in self.var_idx.items():
            x,y,z = xyz
            if p[i] > 0:  list_Df[i] = log( p[i] / p_yz[y,z] )
#            if p[i] > 1.e-30:  list_Df[i] = log( p[i] / p_yz[y,z] )
        Df = matrix(list_Df, (1,N), 'd')

        if zz is None:
            return f,Df

        # Compute zz[0] * Hess f
        # This will be a sparse matrix
        entries = []
        rows    = []
        columns = []
        for xyz,i in self.var_idx.items():
            x,y,z = xyz
            p_yz__x = p_yz[y,z] - p[i] # sum_{* \ne x} p(*,y,z).
            for x_ in self.X:
                if x_==x: # diagonal
                    rows.append( i )
                    columns.append( i )
                    tmp_quot = zz[0] * p_yz__x / p_yz[y,z] # 1/p[x,y,z] - 1/p[*,y,z] = ( p[*,y,z] - p[x,y,z] )/( p[*,y,z] p[x,y,z] )
                    if p[i] > 0 * tmp_quot:   entries.append( tmp_quot / p[i] )
#                    if p[i] > 1.e-100 * tmp_quot:   entries.append( tmp_quot / p[i] )
                    else:
                        print("TROUBLE computing Hessian (diagonal)")
                        entries.append( 0. )
                else: # off diagonal
                    if (x_,y,z) in self.var_idx:
                        j = self.var_idx[ (x_,y,z) ]
                        val = - zz[0] / p_yz[y,z]
                        rows.append( i )
                        columns.append( j )
                        entries.append( val )
                # if diagonal
            # for x_
        # for xyz,i

        zH = spmatrix( entries, rows, columns, (N,N), 'd')
        if self.verbose_output: print("p=",list(p))
        # # print(numpy.squeeze(zH/zz[0]))
        # print("var_idx=",self.var_idx)
        # print("p=",p_dict)
        # print("p_yz=",p_yz)
        # print("H=",zH)
        # # print("Eigen values of Hess f (p) are ",numpy.linalg.eigvals(matrix(zH)),"[",N,"]")
        # print("Eigen vectors:\n", numpy.linalg.eigh(matrix(zH)))
        return f,Df,zH
    #^ callback()


    # make_initial_solution()
    def make_initial_solution(self, orig_q_0=None):
        # make initial solution q_0
        self.p_0 = dict()
        if orig_q_0==None: # no initial solution provided. I'm gonna get some "minimum entropy" thing
            if self.expensive_initial_solution:
                # initial solution is the one minimizing || p ||^2
                N = len(self.var_idx)

                Q = 2*spdiag( matrix( 1., (N,1), 'd' ) )
                q = matrix( 0., (N,1), 'd' )

                qp_solver = solvers.qp(Q, q, self.G, self.h, self.A, self.b)

                # for xyz,i in self.var_idx.items():
                #     self.p_0[xyz] = max(0, qp_solver['x'][i] )
                print("Min 2-norm: ",list( qp_solver['x'] ))
            else:
                for xyz in self.var_idx.keys():
                    self.p_0[xyz] = 1.
        else:
            for xyz in self.var_idx.keys():
                if xyz in orig_q_0:
                    self.p_0[xyz] = orig_q_0[xyz]
                else:
                    self.p_0[xyz] = 0.
    #^ make_initial_solution()

    # solve_it():
    def solve_it(self, _eps=1.e-10):
        self.var_eps = _eps
        self.q_xy = self.tidy_up_distrib(self.orig_marg_xy, self.var_eps)
        self.q_xz = self.tidy_up_distrib(self.orig_marg_xz, self.var_eps)

        if self.verbose_output:
            print("q_xy=",self.q_xy)
            print("q_xz=",self.q_xz)

        self.create_equations()
        self.create_ieqs()
        self.make_initial_solution()
        if self.verbose_output: print(self.p_0)

        self.solver_ret   = solvers.cp(self.callback, G=self.G, h=self.h, A=self.A, b=self.b)
        print("Solver terminated with status ",self.solver_ret['status'])

        self.p_final = dict()
        for xyz,i in self.var_idx.items():
            self.p_final[xyz] = self.solver_ret['x'][i]
        return self.p_final
    #^ solve_it()

    #****************************************************************************************************

    # check_feasible()
    def check_feasible(self, p, use_cleaned_up_margs=False):
        p_xy = marginal_xy(p)
        p_xz = marginal_xz(p)
        thesum = 0.

        if use_cleaned_up_margs:
            for x in self.X:
                for y in self.Y:
                    xy = (x,y)
                    if xy in p_xy.keys():      p_val = p_xy[xy]
                    else:                      p_val = 0.
                    if xy in self.q_xy.keys():         q_val = self.q_xy[xy]
                    else:                              q_val = 0.
                    thesum += abs( p_val - q_val )
            for x in self.X:
                for z in self.Z:
                    xz = (x,z)
                    if xz in p_xz.keys():      p_val = p_xz[xz]
                    else:                      p_val = 0.
                    if xz in self.q_xz.keys():         q_val = self.q_xz[xz]
                    else:                              q_val = 0.
                    thesum += abs( p_val - q_val )
        else: # if NOT use cleaned up margs:
            for x in self.X:
                for y in self.Y:
                    xy = (x,y)
                    if xy in p_xy.keys():      p_val = p_xy[xy]
                    else:                      p_val = 0.
                    if xy in self.orig_marg_xy.keys(): q_val = self.orig_marg_xy[xy]
                    else:                              q_val = 0.
                    thesum += abs( p_val - q_val )
            for x in self.X:
                for z in self.Z:
                    xz = (x,z)
                    if xz in p_xz.keys():      p_val = p_xz[xz]
                    else:                      p_val = 0.
                    if xz in self.orig_marg_xz.keys(): q_val = self.orig_marg_xz[xz]
                    else:                              q_val = 0.
                    thesum += abs( p_val - q_val )

        return thesum
    #^ check_feasible()

    def check_KKT_sol(self,p,why):
        p_yz = marginal_yz(p)
        viol = -1.

        for x in self.X:
            for y in self.Y:
                for z in self.Z:
                    try:               idx_xy = self.marg_of_idx.index((x,y,None))
                    except ValueError: idx_xy = None
                    try:               idx_xz = self.marg_of_idx.index((x,None,z))
                    except ValueError: idx_xz = None

                    if idx_xy == None:  lambda_xy = None
                    else:               lambda_xy = why[idx_xy]
                    if idx_xz == None:  mu_xz = None
                    else:               mu_xz = why[idx_xz]

                    if (x,y,z) in p.keys() and p[x,y,z] > 0:
                        # equation
                        p_xzy = p[x,y,z]
                        rhs = -log(p_xzy/p_yz[y,z])  # >= 0
                        viol = max(viol, abs( lambda_xy + mu_xz - rhs ) )
                    else:
                        # inequality
                        if (y,z) in p_yz.keys() and p_yz[y,z] > 0:
                            if lambda_xy==None or mu_xz==None:
                                pass
                            else:
                                rhs = 1.e400
                                viol = max(viol, rhs - (lambda_xy + mu_xz) )
                        else:
                            rhs = 0.
                            viol = max(viol, rhs - (lambda_xy + mu_xz) )
                    # if
                #^ for z
            #^ for y
        #^ for x
        return viol
    #^ check_KKT_sol()

    class KKT_System:
        import gurobipy as gurobi
        def __init__(self,cui):
            self.cui = cui
            self.model = Compute_UI.KKT_System.gurobi.Model("kkt")
            self.model.params.logToConsole = 0

            # Add the variables:
            self.t_var       = None
            self.lambda_vars = dict()
            self.mu_vars     = dict()

            self.t_var = self.model.addVar(obj=1., name="t")
            for x in self.cui.X:
                for y in self.cui.Y:
                    self.lambda_vars[x,y] = self.model.addVar(name='lambda(%s,%s)' % (x,y))
            for x in self.cui.X:
                for z in self.cui.Z:
                    self.mu_vars[x,z] = self.model.addVar(name='mu(%s,%s)' % (x,z))
            self.model.update()

            # Add the constraints:
            self.constr_leq = dict()
            self.constr_geq = dict()
            for x in self.cui.X:
                for y in self.cui.Y:
                    for z in self.cui.Z:
                        rhs   = 0
                        self.constr_leq[x,y,z] = self.model.addConstr( self.lambda_vars[x,y] + self.mu_vars[x,z] - rhs <= self.t_var , name='eq-le(%s,%s,%s)' % (x,y,z))
                        self.constr_geq[x,y,z] = self.model.addConstr( self.lambda_vars[x,y] + self.mu_vars[x,z] - rhs >= -self.t_var, name='eq-ge(%s,%s,%s)' % (x,y,z))
                    #^ for z
                #^ for y
            #^ for x
            self.model.update()
            self.first_time=True
        #^ __init__()

        def solve(self, p, ZERO=1.e-1000):
            p_yz = marginal_yz_with_cutoff(p,ZERO)
            if self.first_time:
                self.first_time = False
                for x in self.cui.X:
                    for y in self.cui.Y:
                        for z in self.cui.Z:
                            xyz=x,y,z
                            if xyz in p.keys() and p[xyz] > ZERO:
                                # equation
                                p_xyz = p[xyz]
                                rhs = -log(p_xyz/p_yz[y,z])  # >= 0
                                self.constr_geq[ xyz ].setAttr("rhs", rhs)
                                self.constr_leq[ xyz ].setAttr("rhs", rhs)
                            else:
                                # inequality
                                if xyz in self.constr_leq.keys():
                                    self.model.remove(self.constr_leq[xyz])
                                    del self.constr_leq[ xyz ]
                                if (y,z) in p_yz.keys() and p_yz[y,z] > 0:    rhs = 1.e400       # don't need ZERO here,  marginal_yz_w_cutoff()
                                else:                                         rhs = 0.
                                self.constr_geq[ xyz ].setAttr("rhs", rhs)
                            # if
                        #^ for z
                    #^ for y
                #^ for x
            else: # same, but different loop
                for xyz in p.keys():
                    x,y,z=xyz
                    if p[xyz] > ZERO:
                        # equation
                        p_xyz = p[xyz]
                        rhs = -log(p_xyz/p_yz[y,z])  # >= 0
                        self.constr_leq[ xyz ].setAttr("rhs", rhs)
                        self.constr_geq[ xyz ].setAttr("rhs", rhs)
                    else:
                        # inequality
                        if xyz in self.constr_leq.keys():
                            self.model.remove(self.constr_leq[xyz])
                            del self.constr_leq[ xyz ]
                        if (y,z) in p_yz.keys() and p_yz[y,z] > 0:    rhs = 1.e400       # don't need ZERO here,  marginal_yz_w_cutoff()
                        else:                                         rhs = 0.
                        self.constr_geq[ xyz ].setAttr("rhs", rhs)
                    # if
                #^ for xyz
            #^ if/else  first time
            self.model.update()
            self.model.optimize();
            if self.model.status == Compute_UI.KKT_System.gurobi.GRB.Status.OPTIMAL:
                t = self.t_var.getAttr("x")
                return t
            else:
                return None
        #^ solve()
    #^ class KKT_System

    def solve_KKT_system(self, p, ZERO=1.e-1000):
        import gurobipy as gurobi

        model = gurobi.Model("kkt")
        model.params.logToConsole = 0


        # Add the variables:
        t_var       = None
        lambda_vars = dict()
        mu_vars     = dict()

        t_var = model.addVar(obj=1., name="t")
        for x in self.X:
            for y in self.Y:
                lambda_vars[x,y] = model.addVar(name='lambda(%s,%s)' % (x,y))
        for x in self.X:
            for z in self.Z:
                mu_vars[x,z] = model.addVar(name='mu(%s,%s)' % (x,z))
        model.update()

        # Add the constraints:
        p_yz = marginal_yz_with_cutoff(p,ZERO)

        for x in self.X:
            for y in self.Y:
                for z in self.Z:
                    if (x,y,z) in p.keys() and p[x,y,z] > ZERO:
                        # equation
                        p_xyz = p[x,y,z]
                        rhs = -log(p_xyz/p_yz[y,z])  # >= 0
                        model.addConstr( lambda_vars[x,y] + mu_vars[x,z] - rhs <= t_var , name='eqn+(%s,%s,%s)' % (x,y,z))
                        model.addConstr( lambda_vars[x,y] + mu_vars[x,z] - rhs >= -t_var , name='eqn-(%s,%s,%s)' % (x,y,z))
                    else:
                        # inequality
                        if (y,z) in p_yz.keys() and p_yz[y,z] > 0:    rhs = 1.e400       # don't need ZERO here,  marginal_yz_w_cutoff()
                        else:                                         rhs = 0.
                        model.addConstr( lambda_vars[x,y] + mu_vars[x,z] - rhs >= -t_var , name='ieq(%s,%s,%s)' % (x,y,z))
                    # if
                #^ for z
            #^ for y
        #^ for x

        # Run Gurobi:
        model.optimize();

        if model.status == gurobi.GRB.Status.OPTIMAL:
            t = t_var.getAttr("x")
            return t
        else:
            return None
    #^ solve_KKT_system()

    def make_KKT_lp(self,p,filename):
        x_idx = dict()
        for x in self.X:
            x_idx[x] = len(x_idx)
        y_idx = dict()
        for y in self.Y:
            y_idx[y] = len(y_idx)
        z_idx = dict()
        for z in self.Z:
            z_idx[z] = len(z_idx)

        p_yz = marginal_yz(p)

        filecontent = ""
        filecontent += "Minimize\n"
        filecontent += "Obj: t\n"
        filecontent += "Subject To\n"
        for x in self.X:
            for y in self.Y:
                for z in self.Z:
                    lhs = ""
                    lhs += " lambda"+str(x_idx[x])+"_"+str(y_idx[y])
                    lhs += " + "
                    lhs += " mu"+str(x_idx[x])+"_"+str(z_idx[z])
                    if (x,y,z) in p.keys() and p[x,y,z] > 0:
                        # equation
                        p_xzy = p[x,y,z]
                        rhs = -1000*log(p_xzy/p_yz[y,z])  # >= 0
                        filecontent += "p("+str(x_idx[x])+","+str(y_idx[y])+","+str(z_idx[z])+"):  "+lhs+"   -t <= "+str(rhs)+"\n"
                        filecontent += "p("+str(x_idx[x])+","+str(y_idx[y])+","+str(z_idx[z])+"):  "+lhs+"   +t >= "+str(rhs)+"\n"
                    else:
                        # inequality
                        if (y,z) in p_yz.keys() and p_yz[y,z] > 0:    rhs = 1.e100
                        else:                                         rhs = 0
                        filecontent += "p("+str(x_idx[x])+","+str(y_idx[y])+","+str(z_idx[z])+"):  "+lhs+"   +t >= "+str(rhs)+"\n"
                #^ for
            #^ for
        #^ for
        filecontent += "END\n"
        print("Writing KKT system to file ",filename)
        with open(filename, 'w') as thefile:
            thefile.write(filecontent)
    #^ make_KKT_lp()

    def try_to_improve_by_LP(self, p):
        import gurobipy as gurobi

        model = gurobi.Model("improve")
        model.params.logToConsole = 0

        p_yz = marginal_yz(p)

        # Add the variables:
        p_xyz_vars = dict()

        for x in self.X:
            for y in self.Y:
                for z in self.Z:
                    if (x,y,z) in p.keys() and p[x,y,z] > 0:
                        # equation
                        p_xyz = p[x,y,z]
                        obj = -log(p_xyz/p_yz[y,z])  # >= 0
                    else:
                        # inequality
                        if (y,z) in p_yz.keys() and p_yz[y,z] > 0:    obj = 1.e100
                        else:                                         obj = 0.
                    p_xyz_vars[x,y,z] = model.addVar( obj=rhs, lb=0., name='p(%s,%s,%s)' % (x,y,z))
                    # if
                #^ for z
            #^ for y
        #^ for x

        model.update()

        # Add constraints:
        for x in self.X:
            for y in self.Y:
                lambda_vars[x,y] = model.addVar(name='lambda(%s,%s)' % (x,y))
        for x in self.X:
            for z in self.Z:
                mu_vars[x,z] = model.addVar(name='mu(%s,%s)' % (x,z))
        model.update()

        # Add the constraints:
        p_yz = marginal_yz(p)


        # Run Gurobi:
        model.optimize();

        if model.status == gurobi.GRB.Status.OPTIMAL:
            t = t_var.getAttr("x")
            return t
        else:
            print("There has been a terrible mistake! [try_to_improve_LP()]")
            return 1.e400
    #^ try_to_improve_by_LP()


    def check_guess(self, p, y=None, kkt_filename=""):
        infeas_2nm = self.check_feasible(p)
        if y==None: kkt_viol  = self.solve_KKT_system(p)
        else:       kkt_viol  = self.check_KKT_sol(p,y)
        if kkt_filename!="":
            if kkt_filename==None: kkt_filename = "kkt.lp"
            cui.make_KKT_lp(cui.p_final,kkt_filename)
        return infeas_2nm,kkt_viol
    # check_guess()

    def search_for_kkt_solution(self, p, stop_search_kkt_eps=-1., stop_search_prob_eps=1., show_progress=True):
        min_viol = 1.e1000
        arg_min_viol = None
        max_viol = -1.e1000
        delta    = 1.e1000
        kkt_viol_list = []

        the_ZERO_range = [ t    for xyz,t in p.items() ]
        the_ZERO_range.append(0)
        the_ZERO_range.sort()

        prev_viol = -1.e1000
        if show_progress: print("Searching...",end=" ")
        last_best_guess = None
        last_best_guess_kkt = len(p)
        kktsys = Compute_UI.KKT_System(self)
        for the_ZERO in the_ZERO_range:
            if show_progress: print(the_ZERO,end=":")
            kkt_viol = kktsys.solve(p,the_ZERO)
            if show_progress: print(kkt_viol,end="; ")
            if kkt_viol!=None:  max_viol = max(max_viol, kkt_viol)
            else:               max_viol = 1.e1000
            if kkt_viol!=None:
                if the_ZERO <= stop_search_prob_eps:
                    if the_ZERO > 0  and  kkt_viol < last_best_guess_kkt:
                        last_best_guess     = the_ZERO
                        last_best_guess_kkt = kkt_viol
                    if kkt_viol < min_viol:
                        min_viol     = kkt_viol
                        arg_min_viol = the_ZERO
                        if kkt_viol <= stop_search_kkt_eps:
                            if show_progress: print("[Breaking from search.]",end=" ")
                            break
                    delta     = min(delta, prev_viol-kkt_viol)
                    prev_viol = kkt_viol
            #^ if kkt_viol finite
            kkt_viol_list.append( (the_ZERO,kkt_viol) )
            if show_progress==False and the_ZERO > stop_search_prob_eps:
                break
        #^ for the_ZERO
        if show_progress: print("Done\nMin violation",min_viol,"with the_ZERO=",arg_min_viol,"; non-monotonicity:",-delta," max viol:",max_viol)
        if min_viol > stop_search_kkt_eps:
            if show_progress: print("Oh bummer, that's too much KKT violation. Trying fallback: the_ZERO=",last_best_guess)
            if last_best_guess!=None:  arg_min_viol=last_best_guess
            else:
                return None
        return min_viol,arg_min_viol,-delta,max_viol,kkt_viol_list
    # search_for_kkt_solution()

    #****************************************************************************************************

    def options():
        pass
        # solvers.options['show_progress'] = True, False # turns the output to the screen on or off (default: True).
        # solvers.options['maxiters'     ] = 10          # maximum number of iterations (default: 100).
        # solvers.options['abstol'       ] = 1.e-7       # absolute accuracy (default: 1e-7).
        # solvers.options['reltol'       ] = 1.e-6       # relative accuracy (default: 1e-6).
        # solvers.options['feastol'      ] = 1.e-7       # tolerance for feasibility conditions (default: 1e-7).
        # solvers.options['refinement'   ] = 1           # number of iterative refinement steps when solving KKT equations (default: 1).
    #^ options()

#^ class Compute_UI
